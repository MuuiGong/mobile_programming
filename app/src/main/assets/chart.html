<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>R² Chart - TradingView Lightweight Charts</title>
    <script src="lightweight-charts.standalone.development.js"
            onload="console.log('LightweightCharts script loaded')"
            onerror="console.error('Failed to load LightweightCharts script')"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1A1F2E;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding-left: 8px;
            padding-right: 8px;
        }

        .top-bar {
            background-color: #1C1F26;
            border-bottom: 1px solid #2D3139;
            padding: 12px 16px;
            padding-top: calc(12px + env(safe-area-inset-top));
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .coin-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .coin-name {
            font-size: 14px;
            font-weight: 600;
            color: #E1E8ED;
        }

        .current-price {
            font-size: 16px;
            font-weight: 600;
            color: #26a69a;
        }

        .price-change {
            font-size: 12px;
            color: #26a69a;
        }

        #chart-container {
            flex: 1;
            background-color: #1A1F2E;
            position: relative;
            overflow: hidden;
            margin: 8px 0;
            border-radius: 8px;
        }

        #chart {
            width: 100%;
            height: 100%;
        }

        /* 오버레이 캔버스 */
        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: auto;  /* 이벤트 감지를 위해 활성화 */
            touch-action: none;
            background: transparent;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="top-bar">
            <div class="coin-info">
                <span class="coin-name">BTCUSDT</span>
                <span class="current-price" id="currentPrice">--</span>
                <span class="price-change" id="priceChange">--</span>
            </div>
        </div>
        <div id="chart-container">
            <div id="chart"></div>
            <canvas id="overlay-canvas"></canvas>
        </div>
    </div>

    <script>
        console.log('===== CHART.HTML LOADED =====');
        console.log('Script started executing');

        // ========== 거래 데이터 ==========
        let tradeData = {
            entry: null,
            tp: null,
            sl: null,
            currentPrice: null,  // 실제 데이터 로드 전까지 null
            basePrice: null      // 실제 데이터 로드 전까지 null
        };

        let positionType = 'long'; // 'long' or 'short'
        let chart = null;
        let candlestickSeries = null;
        let volumeSeries = null;
        let chartReady = false;
        let pendingKlines = null;

        // 오버레이 캔버스
        let canvas = null;
        let ctx = null;
        let isDragging = false;
        let dragTarget = null; // 'ep', 'tp', 'sl'

        // ========== Lightweight Charts 초기화 ==========
        function initChart() {
            const chartContainer = document.getElementById('chart');

            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }

            if (typeof LightweightCharts === 'undefined' || !LightweightCharts.createChart) {
                console.error('LightweightCharts library is not available');
                return;
            }

            const containerWidth = chartContainer.clientWidth || chartContainer.offsetWidth || 800;
            const containerHeight = chartContainer.clientHeight || chartContainer.offsetHeight || 600;

            console.log('Initializing chart with size:', containerWidth, 'x', containerHeight);

            chart = LightweightCharts.createChart(chartContainer, {
                width: containerWidth,
                height: containerHeight,
                layout: {
                    background: { color: '#1A1F2E' },
                    textColor: '#888',
                },
                grid: {
                    vertLines: { color: '#2D3139' },
                    horzLines: { color: '#2D3139' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#252830',
                },
                timeScale: {
                    borderColor: '#252830',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            if (!chart) {
                console.error('Failed to create chart');
                return;
            }

            // 캔들스틱 시리즈
            console.log('Available methods on chart:', Object.keys(chart));

            // v4.x API 시도
            if (chart.addCandlestickSeries) {
                console.log('Using v4.x addCandlestickSeries');
                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderUpColor: '#26a69a',
                    borderDownColor: '#ef5350',
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
            }
            // v3.x API 시도
            else if (chart.addCandle) {
                console.log('Using v3.x addCandle');
                candlestickSeries = chart.addCandle({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                });
            }
            else {
                console.error('No suitable API found for creating candlestick series');
                console.error('LightweightCharts version might be incompatible');
                return;
            }

            console.log('Candlestick series created:', candlestickSeries);

            // 캔들스틱 price scale에 scaleMargins 설정
            try {
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.3,  // 하단 30%는 볼륨용으로 확보
                        },
                    });
                }
            } catch (e) {
                console.warn('Could not configure right price scale:', e);
            }

            // 볼륨 시리즈 (별도 price scale로 분리하여 하단에 배치)
            if (chart.addHistogramSeries) {
                volumeSeries = chart.addHistogramSeries({
                    color: '#26a69a',
                    priceFormat: {
                        type: 'volume',
                    },
                    priceScaleId: 'volume',
                });
                console.log('Volume series created successfully');
                
                // 볼륨 price scale 설정
                try {
                    const volumePriceScale = chart.priceScale('volume');
                    if (volumePriceScale) {
                        volumePriceScale.applyOptions({
                            visible: false,  // 볼륨 스케일 라벨 숨김
                            scaleMargins: {
                                top: 0.7,   // 상단 70% 여백 (캔들스틱 영역 확보)
                                bottom: 0,  // 하단 여백 없음
                            },
                        });
                    }
                } catch (e) {
                    console.warn('Could not configure volume price scale:', e);
                }
            }

            // 샘플 데이터 생성 제거 - 실제 데이터만 사용
            // generateSampleData();

            // 리사이즈 핸들러
            window.addEventListener('resize', () => {
                if (chart && chartContainer) {
                    const newWidth = chartContainer.clientWidth || chartContainer.offsetWidth;
                    const newHeight = chartContainer.clientHeight || chartContainer.offsetHeight;
                    if (newWidth > 0 && newHeight > 0) {
                        chart.resize(newWidth, newHeight);
                    }
                }
            });

            console.log('Chart initialization completed');
        }

        // ========== 샘플 데이터 생성 ==========
        // 목 데이터 제거 - 실제 데이터만 사용
        // function generateSampleData() {
        //     ... 제거됨 ...
        // }

        // ========== 오버레이 캔버스 초기화 ==========
        function initCanvas() {
            canvas = document.getElementById('overlay-canvas');
            if (!canvas) {
                console.error('overlay-canvas element not found');
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Failed to get 2d context');
                return;
            }

            resizeCanvas();

            // 이벤트 리스너
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd);
            
            console.log('Canvas initialized, canvas:', !!canvas, 'ctx:', !!ctx);
            
            // 캔버스 초기화 후 오버레이 그리기 시도
            setTimeout(() => {
                drawOverlay();
                console.log('Initial overlay drawn after canvas init');
            }, 100);
        }

        function resizeCanvas() {
            if (!canvas) {
                console.warn('resizeCanvas: canvas not initialized');
                return;
            }
            
            const container = document.getElementById('chart-container');
            if (!container) {
                console.warn('resizeCanvas: chart-container not found');
                return;
            }
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // ========== 오버레이 그리기 ==========
        function drawOverlay() {
            console.log('=== drawOverlay called ===');
            console.log('Current positionType:', positionType, 'type:', typeof positionType);
            console.log('Current tradeData:', JSON.stringify(tradeData));

            if (!canvas || !ctx || !candlestickSeries) {
                console.error('drawOverlay: Missing components', {
                    canvas: !!canvas,
                    ctx: !!ctx,
                    candlestickSeries: !!candlestickSeries
                });
                return;
            }

            // 캔버스 크기 확인 및 업데이트
            const container = document.getElementById('chart-container');
            if (!container) {
                console.error('drawOverlay: chart-container not found');
                return;
            }
            
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            console.log('Container size:', containerWidth, 'x', containerHeight);
            
            if (canvas.width !== containerWidth || canvas.height !== containerHeight) {
                canvas.width = containerWidth;
                canvas.height = containerHeight;
                console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
            }

            if (canvas.width === 0 || canvas.height === 0) {
                console.warn('drawOverlay: Canvas size is 0, retrying...');
                setTimeout(() => drawOverlay(), 100);
                return;
            }

            // 캔버스가 보이도록 강제
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';

            // 캔버스 완전히 클리어 (여러 번 시도하여 이전 그림 완전히 제거)
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!candlestickSeries) {
                console.warn('drawOverlay: candlestickSeries not available, retrying...');
                setTimeout(() => {
                    if (candlestickSeries) {
                        drawOverlay();
                    }
                }, 100);
                return;
            }

            // priceToCoordinate는 candlestickSeries에서 직접 호출해야 함
            if (typeof candlestickSeries.priceToCoordinate !== 'function') {
                console.warn('drawOverlay: priceToCoordinate method not available, retrying...');
                setTimeout(() => {
                    if (candlestickSeries && typeof candlestickSeries.priceToCoordinate === 'function') {
                        drawOverlay();
                    }
                }, 100);
                return;
            }

            console.log('Trade data:', tradeData);

            // EP, TP, SL 값이 있는지 확인
            if (tradeData.entry === null && tradeData.tp === null && tradeData.sl === null) {
                console.warn('drawOverlay: No trade data to draw');
                return;
            }

            // 모든 라인의 y 좌표 계산 (색칠과 라인 그리기 모두에 필요)
            let epY = null, tpY = null, slY = null;

            if (tradeData.entry !== null && tradeData.entry > 0) {
                try {
                    epY = candlestickSeries.priceToCoordinate(tradeData.entry);
                } catch (e) {
                    console.error('Error calculating EP coordinate:', e);
                }
            }

            if (tradeData.tp !== null && tradeData.tp > 0) {
                try {
                    tpY = candlestickSeries.priceToCoordinate(tradeData.tp);
                } catch (e) {
                    console.error('Error calculating TP coordinate:', e);
                }
            }

            if (tradeData.sl !== null && tradeData.sl > 0) {
                try {
                    slY = candlestickSeries.priceToCoordinate(tradeData.sl);
                } catch (e) {
                    console.error('Error calculating SL coordinate:', e);
                }
            }

            // positionType 명시적 확인 (window.positionType 우선 사용하여 최신 값 보장)
            const currentPositionType = window.positionType || positionType;
            const isLong = String(currentPositionType) === 'long';
            const isShort = String(currentPositionType) === 'short';
            console.log('drawOverlay - currentPositionType:', currentPositionType, 'isLong:', isLong, 'isShort:', isShort);
            console.log('drawOverlay - window.positionType:', window.positionType, 'positionType:', positionType);
            console.log('drawOverlay - tradeData values:', 'entry:', tradeData.entry, 'tp:', tradeData.tp, 'sl:', tradeData.sl);
            console.log('drawOverlay - coordinate values:', 'epY:', epY, 'tpY:', tpY, 'slY:', slY);

            // 색칠은 라인 그리기 전에 실행 (라인이 색칠 위에 표시되도록)
            // 컴포지트 모드를 'source-over'로 설정하여 이전 그림을 완전히 덮어씀
            ctx.globalCompositeOperation = 'source-over';

            // **핵심**: 포지션 타입에 따라 색이 결정됨 (위치 무관!)
            // Long: EP 위쪽 = 녹색(수익), EP 아래쪽 = 빨강(손실)
            // Short: EP 위쪽 = 빨강(손실), EP 아래쪽 = 녹색(수익)

            if (epY !== null && tpY !== null && slY !== null) {
                console.log('Drawing areas with EP as boundary - epY:', epY, 'tpY:', tpY, 'slY:', slY);

                const currentIsLong = String(window.positionType || positionType) === 'long';
                console.log('Current position type:', currentIsLong ? 'LONG' : 'SHORT');

                // 위쪽과 아래쪽의 y 좌표 계산
                const upperY = Math.min(tpY, slY); // 위에 있는 것
                const lowerY = Math.max(tpY, slY); // 아래에 있는 것

                // 색은 오직 포지션 타입에만 의존!
                const upperColor = currentIsLong ? 'rgba(38, 166, 154, 0.1)' : 'rgba(239, 83, 80, 0.1)'; // Long=녹색, Short=빨강
                const lowerColor = currentIsLong ? 'rgba(239, 83, 80, 0.1)' : 'rgba(38, 166, 154, 0.1)'; // Long=빨강, Short=녹색

                console.log('Drawing UPPER area from', upperY, 'to', epY, 'with color:', upperColor, '(positionType:', currentIsLong ? 'LONG' : 'SHORT', ')');
                ctx.fillStyle = upperColor;
                ctx.fillRect(0, upperY, canvas.width, epY - upperY);

                console.log('Drawing LOWER area from', epY, 'to', lowerY, 'with color:', lowerColor, '(positionType:', currentIsLong ? 'LONG' : 'SHORT', ')');
                ctx.fillStyle = lowerColor;
                ctx.fillRect(0, epY, canvas.width, lowerY - epY);

            } else {
                console.log('Cannot draw areas - missing coordinates. epY:', epY, 'tpY:', tpY, 'slY:', slY);
            }

            // 각 라인 쌍이 겹치는지 개별적으로 확인 (5픽셀 이내면 겹침으로 간주)
            const threshold = 5;
            const epTpOverlap = epY !== null && tpY !== null && Math.abs(epY - tpY) < threshold;
            const epSlOverlap = epY !== null && slY !== null && Math.abs(epY - slY) < threshold;
            const tpSlOverlap = tpY !== null && slY !== null && Math.abs(tpY - slY) < threshold;

            // EP 라인과 버튼들
            if (epY !== null && !isNaN(epY)) {
                if (epY >= -100 && epY <= canvas.height + 100) {
                    // EP 라인 그리기
                    ctx.strokeStyle = '#2962FF';
                    ctx.lineWidth = 3;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, epY);
                    ctx.lineTo(canvas.width, epY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // EP 라인에 버튼 표시
                    const buttonWidth = 40;
                    const buttonHeight = 24;
                    const spacing = 5;
                    const startX = 10;
                    const buttonY = epY - buttonHeight / 2;
                    
                    // EP 버튼 (항상 표시)
                    drawButton(startX, buttonY, buttonWidth, buttonHeight, '#2962FF', 'EP');
                    
                    // TP 버튼 (TP가 EP와 겹치거나 TP가 없을 때만 EP 라인에 표시)
                    if (epTpOverlap || (tradeData.tp === null || tradeData.tp === 0)) {
                        drawButton(startX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight, '#26a69a', 'TP');
                    }
                    
                    // SL 버튼 (SL이 EP와 겹치거나 SL이 없을 때만 EP 라인에 표시)
                    if (epSlOverlap || (tradeData.sl === null || tradeData.sl === 0)) {
                        drawButton(startX + (buttonWidth + spacing) * 2, buttonY, buttonWidth, buttonHeight, '#ef5350', 'SL');
                    }
                }
            }

            // TP 라인과 TP 버튼 (EP와 겹치지 않을 때만)
            if (tpY !== null && !isNaN(tpY) && !epTpOverlap) {
                if (tpY >= -100 && tpY <= canvas.height + 100) {
                    drawLineWithButton(tpY, '#26a69a', 'TP');
                }
            }

            // SL 라인과 SL 버튼 (EP와 겹치지 않을 때만)
            if (slY !== null && !isNaN(slY) && !epSlOverlap) {
                if (slY >= -100 && slY <= canvas.height + 100) {
                    drawLineWithButton(slY, '#ef5350', 'SL');
                }
            }

            console.log('=== drawOverlay completed ===');
        }

        function drawLineWithButton(y, color, label) {
            if (!ctx || !canvas) {
                console.error('drawLineWithButton: ctx or canvas not available');
                return;
            }
            
            // 가로선 그리기
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            
            if (label === 'EP') {
                // EP는 점선
                ctx.setLineDash([5, 5]);
            } else {
                // TP, SL은 실선
                ctx.setLineDash([]);
            }
            
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            ctx.setLineDash([]);

            // 버튼을 라인 중앙에 위치
            const buttonWidth = 40;
            const buttonHeight = 24;
            const startX = 10;
            const buttonY = y - buttonHeight / 2; // 라인 중앙에 버튼 위치

            // 해당 라인의 버튼만 그리기
            drawButton(startX, buttonY, buttonWidth, buttonHeight, color, label);
        }

        function drawButtonsOnEPLine(y) {
            if (!ctx || !canvas) return;
            
            const buttonWidth = 40;
            const buttonHeight = 24;
            const spacing = 5;
            const startX = 10;
            const buttonY = y - buttonHeight / 2;

            // EP 버튼 (항상 표시)
            drawButton(startX, buttonY, buttonWidth, buttonHeight, '#2962FF', 'EP');

            // TP 버튼 (항상 표시 - 선들이 겹칠 때)
            drawButton(startX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight, '#26a69a', 'TP');

            // SL 버튼 (항상 표시 - 선들이 겹칠 때)
            drawButton(startX + (buttonWidth + spacing) * 2, buttonY, buttonWidth, buttonHeight, '#ef5350', 'SL');
        }

        function drawLineOnly(y, color) {
            if (!ctx || !canvas) {
                console.error('drawLineOnly: ctx or canvas not available');
                return;
            }
            
            // 가로선 (실선) - TP, SL 라인
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
        }

        function drawLine(y, color, label) {
            if (!ctx || !canvas) {
                console.error('drawLine: ctx or canvas not available');
                return;
            }
            
            // 가로선 (점선)
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;  // 더 두껍게
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            ctx.stroke();
            ctx.setLineDash([]);

            // 라벨 (TP, SL 라인용)
            drawButton(10, y - 12, 40, 24, color, label);
        }

        function drawButton(x, y, width, height, color, text) {
            if (!ctx) {
                console.error('drawButton: ctx not available');
                return;
            }
            
            // 버튼 배경
            ctx.fillStyle = color;
            ctx.fillRect(x, y, width, height);

            // 텍스트
            ctx.fillStyle = '#FFFFFF';
            ctx.font = 'bold 12px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x + width / 2, y + height / 2);
        }

        // ========== 현재가 업데이트 ==========
        function updateCurrentPrice(price) {
            if (tradeData.basePrice === null || tradeData.basePrice === 0) {
                tradeData.basePrice = price;
            }

            tradeData.currentPrice = price;

            document.getElementById('currentPrice').textContent = `$${price.toFixed(2)}`;

            const change = ((price - tradeData.basePrice) / tradeData.basePrice * 100).toFixed(2);
            const changeElement = document.getElementById('priceChange');
            changeElement.textContent = `${change >= 0 ? '+' : ''}${change}%`;
            changeElement.style.color = change >= 0 ? '#26a69a' : '#ef5350';

            drawOverlay();
        }

        // ========== 드래그 이벤트 핸들러 ==========
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function getButtonAtPos(x, y) {
            if (!candlestickSeries) return null;

            if (typeof candlestickSeries.priceToCoordinate !== 'function') return null;

            const buttonWidth = 40;
            const buttonHeight = 24;
            const spacing = 5;
            const startX = 10;

            // 모든 라인의 y 좌표 계산
            let epY = null, tpY = null, slY = null;
            
            if (tradeData.entry !== null && tradeData.entry > 0) {
                epY = candlestickSeries.priceToCoordinate(tradeData.entry);
            }
            if (tradeData.tp !== null && tradeData.tp > 0) {
                tpY = candlestickSeries.priceToCoordinate(tradeData.tp);
            }
            if (tradeData.sl !== null && tradeData.sl > 0) {
                slY = candlestickSeries.priceToCoordinate(tradeData.sl);
            }

            // 각 라인 쌍이 겹치는지 개별적으로 확인
            const threshold = 5;
            const epTpOverlap = epY !== null && tpY !== null && Math.abs(epY - tpY) < threshold;
            const epSlOverlap = epY !== null && slY !== null && Math.abs(epY - slY) < threshold;

            // TP 버튼 체크 (TP 라인에 있는 버튼, EP와 겹치지 않을 때만)
            if (tpY !== null && !isNaN(tpY) && !epTpOverlap) {
                const buttonY = tpY - buttonHeight / 2;
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'tp';
                }
            }

            // SL 버튼 체크 (SL 라인에 있는 버튼, EP와 겹치지 않을 때만)
            if (slY !== null && !isNaN(slY) && !epSlOverlap) {
                const buttonY = slY - buttonHeight / 2;
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'sl';
                }
            }

            // EP 라인에 있는 버튼들 체크
            if (epY !== null && !isNaN(epY)) {
                const buttonY = epY - buttonHeight / 2;

                // EP 버튼 체크
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'ep';
                }

                // TP 버튼 체크 (EP와 겹치거나 TP 라인이 없을 때 EP 라인에 있음)
                if (epTpOverlap || (tradeData.tp === null || tradeData.tp === 0)) {
                    if (x >= startX + buttonWidth + spacing && x <= startX + (buttonWidth + spacing) * 2 &&
                        y >= buttonY && y <= buttonY + buttonHeight) {
                        return 'tp';
                    }
                }

                // SL 버튼 체크 (EP와 겹치거나 SL 라인이 없을 때 EP 라인에 있음)
                if (epSlOverlap || (tradeData.sl === null || tradeData.sl === 0)) {
                    if (x >= startX + (buttonWidth + spacing) * 2 && x <= startX + (buttonWidth + spacing) * 3 &&
                        y >= buttonY && y <= buttonY + buttonHeight) {
                        return 'sl';
                    }
                }
            }

            return null;
        }

        function handleStart(e) {
            const pos = getPointerPos(e);
            const button = getButtonAtPos(pos.x, pos.y);

            if (button) {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                dragTarget = button;
                console.log('Drag started:', button);
            } else {
                // 버튼이 아닌 곳을 클릭하면 차트 이벤트로 전달
                // 이벤트를 막지 않고 캔버스를 일시적으로 투과시켜 차트가 직접 이벤트를 받도록 함
                if (canvas) {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    // 캔버스를 일시적으로 투과시킴
                    canvas.style.pointerEvents = 'none';
                    
                    // 즉시 차트 요소에 이벤트 전달
                    setTimeout(() => {
                        const elementBelow = document.elementFromPoint(clientX, clientY);
                        if (elementBelow && elementBelow !== canvas) {
                            // 마우스 이벤트로 변환하여 전달 (가장 호환성이 좋음)
                            const mouseEvent = new MouseEvent('mousedown', {
                                bubbles: true,
                                cancelable: true,
                                clientX: clientX,
                                clientY: clientY,
                                button: e.touches ? 0 : e.button,
                                buttons: e.touches ? 1 : e.buttons,
                                view: window
                            });
                            
                            elementBelow.dispatchEvent(mouseEvent);
                            
                            // 터치 이벤트도 전달 시도 (지원되는 경우)
                            if (e.touches) {
                                setTimeout(() => {
                                    try {
                                        const touchEvent = new TouchEvent('touchstart', {
                                            bubbles: true,
                                            cancelable: true,
                                            touches: e.touches,
                                            targetTouches: e.touches,
                                            changedTouches: e.touches
                                        });
                                        elementBelow.dispatchEvent(touchEvent);
                                    } catch (err) {
                                        // TouchEvent가 지원되지 않는 경우 무시
                                    }
                                }, 0);
                            }
                        }
                        
                        // 짧은 시간 후 캔버스 다시 활성화
                        setTimeout(() => {
                            if (canvas) {
                                canvas.style.pointerEvents = 'auto';
                            }
                        }, 100);
                    }, 0);
                }
            }
        }

        function handleMove(e) {
            if (!isDragging || !dragTarget || !candlestickSeries) return;

            e.preventDefault();
            e.stopPropagation();
            const pos = getPointerPos(e);
            
            if (typeof candlestickSeries.coordinateToPrice !== 'function') {
                console.warn('coordinateToPrice not available');
                return;
            }

            let price = candlestickSeries.coordinateToPrice(pos.y);
            if (price === null || price === undefined || isNaN(price)) {
                console.warn('Invalid price:', price, 'y:', pos.y);
                return;
            }
            
            console.log('Dragging:', dragTarget, 'price:', price);

            // 가격 제한 로직
            if (dragTarget === 'ep') {
                console.log('EP drag - current positionType:', positionType, 'type:', typeof positionType);
                console.log('EP drag - initial price:', price, 'TP:', tradeData.tp, 'SL:', tradeData.sl);

                // EP 드래그 시 TP와 SL 사이에서만 이동 가능하도록 제한
                const isLong = String(positionType) === 'long';
                const isShort = String(positionType) === 'short';
                console.log('EP drag - positionType check:', positionType, 'isLong:', isLong, 'isShort:', isShort);

                if (isLong) {
                    console.log('EP drag - long position logic');
                    // 롱: TP >= EP >= SL (EP는 TP와 SL 사이)
                    let minPrice = -Infinity;
                    let maxPrice = Infinity;

                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        minPrice = tradeData.sl; // EP는 SL보다 낮아질 수 없음
                    }
                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        maxPrice = tradeData.tp; // EP는 TP보다 높아질 수 없음
                    }

                    price = Math.max(price, minPrice);
                    price = Math.min(price, maxPrice);
                    console.log('Long: EP limited between SL:', minPrice, 'and TP:', maxPrice, 'final price:', price);

                } else if (isShort) {
                    console.log('EP drag - short position logic');
                    // 숏: SL >= EP >= TP (EP는 TP와 SL 사이)
                    let minPrice = -Infinity;
                    let maxPrice = Infinity;

                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        minPrice = tradeData.tp; // EP는 TP보다 낮아질 수 없음
                    }
                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        maxPrice = tradeData.sl; // EP는 SL보다 높아질 수 없음
                    }

                    price = Math.max(price, minPrice);
                    price = Math.min(price, maxPrice);
                    console.log('Short: EP limited between TP:', minPrice, 'and SL:', maxPrice, 'final price:', price);
                } else {
                    console.log('EP drag - unknown position type:', positionType);
                }
                tradeData.entry = price;
                console.log('EP updated to:', price, 'positionType:', positionType);
            } else if (dragTarget === 'tp') {
                const isLong = String(positionType) === 'long';
                if (tradeData.entry === null || tradeData.entry === 0) {
                    // EP가 없으면 제한 없음
                    tradeData.tp = price;
                } else {
                    if (isLong) {
                        // 롱: TP는 진입가보다 낮아질 수 없음, SL보다 낮아질 수 없음
                        price = Math.max(price, tradeData.entry);
                        if (tradeData.sl !== null && tradeData.sl > 0) {
                            price = Math.max(price, tradeData.sl);
                        }
                    } else {
                        // 숏: TP는 진입가보다 높아질 수 없음, SL보다 높아질 수 없음
                        price = Math.min(price, tradeData.entry);
                        if (tradeData.sl !== null && tradeData.sl > 0) {
                            price = Math.min(price, tradeData.sl);
                        }
                    }
                    tradeData.tp = price;
                }
            } else if (dragTarget === 'sl') {
                const isLong = String(positionType) === 'long';
                if (tradeData.entry === null || tradeData.entry === 0) {
                    // EP가 없으면 제한 없음
                    tradeData.sl = price;
                } else {
                    if (isLong) {
                        // 롱: SL은 진입가보다 높아질 수 없음, TP보다 높아질 수 없음
                        price = Math.min(price, tradeData.entry);
                        if (tradeData.tp !== null && tradeData.tp > 0) {
                            price = Math.min(price, tradeData.tp);
                        }
                    } else {
                        // 숏: SL은 진입가보다 낮아질 수 없음, TP보다 낮아질 수 없음
                        price = Math.max(price, tradeData.entry);
                        if (tradeData.tp !== null && tradeData.tp > 0) {
                            price = Math.max(price, tradeData.tp);
                        }
                    }
                    tradeData.sl = price;
                }
            }

            drawOverlay();
            
            // Android에 가격 업데이트 전달 (드래그 중에도 실시간 업데이트)
            updateAndroidInputs();
        }

        function updateAndroidInputs() {
            // Android WebView에 가격 업데이트 전달 (개별 메서드 호출)
            console.log('updateAndroidInputs called:', { 
                entry: tradeData.entry, 
                tp: tradeData.tp, 
                sl: tradeData.sl 
            });
            
            if (window.Android) {
                try {
                    // Entry 가격 업데이트
                    if (tradeData.entry !== null && tradeData.entry > 0) {
                        if (typeof window.Android.onEntryPriceChanged === 'function') {
                            window.Android.onEntryPriceChanged(tradeData.entry);
                            console.log('onEntryPriceChanged called with:', tradeData.entry);
                        }
                    }
                    
                    // TP 가격 업데이트
                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        if (typeof window.Android.onTakeProfitChanged === 'function') {
                            window.Android.onTakeProfitChanged(tradeData.tp);
                            console.log('onTakeProfitChanged called with:', tradeData.tp);
                        }
                    }
                    
                    // SL 가격 업데이트
                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        if (typeof window.Android.onStopLossChanged === 'function') {
                            window.Android.onStopLossChanged(tradeData.sl);
                            console.log('onStopLossChanged called with:', tradeData.sl);
                        }
                    }
                } catch (e) {
                    console.error('Error calling Android methods:', e);
                }
            } else {
                console.warn('window.Android is not available');
            }
        }

        function handleEnd(e) {
            if (isDragging) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Drag ended');
                isDragging = false;
                dragTarget = null;
                // Android에 최종 가격 업데이트 전달
                updateAndroidInputs();
            }
        }

        // ========== Binance OHLC 데이터 설정 ==========
        window.setOHLCData = function(klines) {
            console.log('===== setOHLCData called =====');
            console.log('Klines count:', klines ? klines.length : 0);

            if (!klines || klines.length === 0) {
                console.warn('No OHLC data provided');
                return;
            }

            if (!chartReady || !candlestickSeries) {
                console.warn('Chart not ready yet, storing klines for later');
                pendingKlines = klines;
                return;
            }

            try {
                const candleData = [];
                const volumeData = [];

                for (let i = 0; i < klines.length; i++) {
                    const kline = klines[i];
                    if (kline && kline.length >= 6) {
                        const openTime = Math.floor(kline[0] / 1000);
                        const open = parseFloat(kline[1]);
                        const high = parseFloat(kline[2]);
                        const low = parseFloat(kline[3]);
                        const close = parseFloat(kline[4]);
                        const volume = parseFloat(kline[5]);

                        candleData.push({
                            time: openTime,
                            open: open,
                            high: high,
                            low: low,
                            close: close
                        });

                        volumeData.push({
                            time: openTime,
                            value: volume,
                            color: close > open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                        });
                    }
                }

                candlestickSeries.setData(candleData);
                if (volumeSeries && volumeData.length > 0) {
                    volumeSeries.setData(volumeData);
                }

                // 데이터 설정 후 scaleMargins 다시 적용하여 분리 보장
                if (candlestickSeries) {
                    candlestickSeries.applyOptions({
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.3,  // 하단 30%는 볼륨용으로 확보
                        },
                    });
                }
                if (volumeSeries) {
                    volumeSeries.applyOptions({
                        scaleMargins: {
                            top: 0.7,   // 상단 70% 여백 (캔들스틱 영역 확보)
                            bottom: 0,  // 하단 여백 없음
                        },
                    });
                }

                if (chart && candleData.length > 0) {
                    chart.timeScale().fitContent();
                }

                if (candleData.length > 0) {
                    const lastCandle = candleData[candleData.length - 1];
                    updateCurrentPrice(lastCandle.close);

                    // EP만 자동 초기화 (TP, SL은 나중에 드래그로 설정)
                    if (tradeData.entry === null) {
                        tradeData.entry = lastCandle.close;
                        tradeData.tp = null;  // 처음에는 TP 없음
                        tradeData.sl = null;  // 처음에는 SL 없음

                        console.log('Auto-initialized EP only from OHLC data:', {
                            entry: tradeData.entry
                        });

                        // 데이터 로드 후 기본 포지션 타입 설정 (롱)
                        setTimeout(() => {
                            if (typeof adjustLinesForPositionType === 'function') {
                                console.log('Setting initial position type to LONG after OHLC data load');
                                adjustLinesForPositionType('long');
                            }
                        }, 300);
                    }
                    
                    // 오버레이 다시 그리기 (여러 번 시도)
                    setTimeout(() => {
                        drawOverlay();
                    }, 200);
                    setTimeout(() => {
                        drawOverlay();
                    }, 500);
                    setTimeout(() => {
                        drawOverlay();
                    }, 1000);
                }
            } catch (error) {
                console.error('Error setting OHLC data:', error);
            }
        };

        // ========== 실시간 캔들 업데이트 ==========
        window.updateKline = function(openTime, open, high, low, close, volume) {
            if (!candlestickSeries) return;

            try {
                const time = Math.floor(openTime / 1000);

                candlestickSeries.update({
                    time: time,
                    open: parseFloat(open),
                    high: parseFloat(high),
                    low: parseFloat(low),
                    close: parseFloat(close)
                });

                if (volumeSeries) {
                    volumeSeries.update({
                        time: time,
                        value: parseFloat(volume),
                        color: parseFloat(close) > parseFloat(open) ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                    });
                }

                updateCurrentPrice(parseFloat(close));
            } catch (error) {
                console.error('Error updating kline:', error);
            }
        };

        // ========== Android 인터페이스 ==========
        // Android에서 호출하는 함수 (updateLines로도 호출 가능)
        window.updateLines = function(entry, tp, sl) {
            console.log('updateLines called (alias for updateTradeData):', { entry, tp, sl });
            window.updateTradeData(entry, tp, sl);
        };
        
        window.updateTradeData = function(entry, tp, sl) {
            console.log('===== updateTradeData called =====');
            console.log('Parameters:', { entry, tp, sl });
            console.log('Current tradeData before update:', JSON.parse(JSON.stringify(tradeData)));
            
            let updated = false;
            
            if (entry !== undefined && entry !== null && entry !== '') {
                const entryValue = parseFloat(entry);
                if (!isNaN(entryValue) && entryValue > 0) {
                    if (tradeData.entry !== entryValue) {
                        tradeData.entry = entryValue;
                        updated = true;
                        console.log('Entry updated to:', entryValue);
                    }
                } else if (entry === '' || entry === '0' || entry === '0.00') {
                    if (tradeData.entry !== null) {
                        tradeData.entry = null;
                        updated = true;
                        console.log('Entry cleared');
                    }
                }
            }
            
            if (tp !== undefined && tp !== null && tp !== '') {
                const tpValue = parseFloat(tp);
                if (!isNaN(tpValue) && tpValue > 0) {
                    if (tradeData.tp !== tpValue) {
                        tradeData.tp = tpValue;
                        updated = true;
                        console.log('TP updated to:', tpValue);
                    }
                } else if (tp === '' || tp === '0' || tp === '0.00') {
                    if (tradeData.tp !== null) {
                        tradeData.tp = null;
                        updated = true;
                        console.log('TP cleared');
                    }
                }
            }
            
            if (sl !== undefined && sl !== null && sl !== '') {
                const slValue = parseFloat(sl);
                if (!isNaN(slValue) && slValue > 0) {
                    if (tradeData.sl !== slValue) {
                        tradeData.sl = slValue;
                        updated = true;
                        console.log('SL updated to:', slValue);
                    }
                } else if (sl === '' || sl === '0' || sl === '0.00') {
                    if (tradeData.sl !== null) {
                        tradeData.sl = null;
                        updated = true;
                        console.log('SL cleared');
                    }
                }
            }
            
            if (updated) {
                console.log('Updated tradeData:', JSON.parse(JSON.stringify(tradeData)));
                // 여러 번 시도하여 확실히 그리기
                setTimeout(() => {
                    drawOverlay();
                }, 50);
                setTimeout(() => {
                    drawOverlay();
                }, 200);
                setTimeout(() => {
                    drawOverlay();
                }, 500);
            } else {
                console.log('No update needed');
            }
        };

        window.setPositionType = function(type) {
            positionType = String(type).toLowerCase();
            console.log('Position type set to:', positionType);
            // 포지션 타입 변경 시 즉시 오버레이 다시 그리기
            setTimeout(() => {
                drawOverlay();
                console.log('Redrew overlay after position type change');
            }, 50);
        };

        // ========== 포지션 타입 변경 시 라인 위치 자동 조정 ==========
        window.adjustLinesForPositionType = function(newPositionType) {
            console.log('=== ADJUSTING LINES FOR POSITION TYPE ===');
            console.log('New position type:', newPositionType);
            console.log('Current position type:', positionType);
            console.log('Current trade data:', JSON.stringify(tradeData));

            // 포지션 타입 설정 (명시적으로 문자열로 변환 및 전역 변수에도 저장)
            const newType = String(newPositionType).toLowerCase();
            positionType = newType;
            window.positionType = newType; // 전역 window 객체에도 저장
            console.log('Position type set to:', positionType);
            console.log('Window position type:', window.positionType);
            console.log('Position type is now:', positionType, 'type:', typeof positionType);
            console.log('Position type comparison - isLong:', positionType === 'long', 'isShort:', positionType === 'short');

            // 현재 캔버스 상태 저장 (디버깅용)
            console.log('Canvas state - pointerEvents:', canvas ? canvas.style.pointerEvents : 'no canvas');

            // 현재 값들 저장
            let currentTp = tradeData.tp;
            let currentSl = tradeData.sl;
            let currentEntry = tradeData.entry;

            console.log('Current values - TP:', currentTp, 'SL:', currentSl, 'Entry:', currentEntry);

            // EP가 없으면 설정
            if (currentEntry === null || currentEntry === 0) {
                currentEntry = tradeData.currentPrice || 95902.92;
                tradeData.entry = currentEntry;
                console.log('Set entry to current price:', currentEntry);
            }

            // positionType 명시적 확인
            const isLong = positionType === 'long';
            const isShort = positionType === 'short';
            console.log('adjustLinesForPositionType - isLong:', isLong, 'isShort:', isShort);

            // TP와 SL 위치 조정 - EP를 기준으로 올바른 위치에 배치
            console.log('Adjusting TP and SL positions for position type:', positionType);
            console.log('Current values - Entry:', currentEntry, 'TP:', currentTp, 'SL:', currentSl);

            if (currentTp !== null && currentSl !== null) {
                // 둘 다 있으면 EP를 기준으로 올바른 위치에 재배치
                const higherValue = Math.max(currentTp, currentSl);
                const lowerValue = Math.min(currentTp, currentSl);

                if (isLong) {
                    // 롱: TP > EP > SL
                    // EP보다 높은 값이 TP, EP보다 낮은 값이 SL
                    tradeData.tp = higherValue;
                    tradeData.sl = lowerValue;
                    console.log('Long position - TP:', tradeData.tp, 'SL:', tradeData.sl, 'Entry:', currentEntry);
                } else {
                    // 숏: SL > EP > TP
                    // EP보다 높은 값이 SL, EP보다 낮은 값이 TP
                    tradeData.sl = higherValue;
                    tradeData.tp = lowerValue;
                    console.log('Short position - TP:', tradeData.tp, 'SL:', tradeData.sl, 'Entry:', currentEntry);
                }
            } else if (currentTp !== null) {
                // TP만 있으면 SL을 EP 기준으로 설정
                if (isLong) {
                    // 롱: TP > EP > SL
                    if (currentTp > currentEntry) {
                        tradeData.tp = currentTp;
                        tradeData.sl = currentEntry * 0.99;
                    } else {
                        // TP가 EP보다 낮으면 EP 기준으로 재설정
                        tradeData.tp = currentEntry * 1.01;
                        tradeData.sl = currentEntry * 0.99;
                    }
                } else {
                    // 숏: SL > EP > TP
                    if (currentTp < currentEntry) {
                        tradeData.tp = currentTp;
                        tradeData.sl = currentEntry * 1.01;
                    } else {
                        // TP가 EP보다 높으면 EP 기준으로 재설정
                        tradeData.tp = currentEntry * 0.99;
                        tradeData.sl = currentEntry * 1.01;
                    }
                }
                console.log('Added SL based on TP - TP:', tradeData.tp, 'SL:', tradeData.sl);
            } else if (currentSl !== null) {
                // SL만 있으면 TP를 EP 기준으로 설정
                if (isLong) {
                    // 롱: TP > EP > SL
                    if (currentSl < currentEntry) {
                        tradeData.sl = currentSl;
                        tradeData.tp = currentEntry * 1.01;
                    } else {
                        // SL이 EP보다 높으면 EP 기준으로 재설정
                        tradeData.sl = currentEntry * 0.99;
                        tradeData.tp = currentEntry * 1.01;
                    }
                } else {
                    // 숏: SL > EP > TP
                    if (currentSl > currentEntry) {
                        tradeData.sl = currentSl;
                        tradeData.tp = currentEntry * 0.99;
                    } else {
                        // SL이 EP보다 낮으면 EP 기준으로 재설정
                        tradeData.sl = currentEntry * 1.01;
                        tradeData.tp = currentEntry * 0.99;
                    }
                }
                console.log('Added TP based on SL - TP:', tradeData.tp, 'SL:', tradeData.sl);
            } else {
                // 둘 다 없으면 기본값 설정
                tradeData.tp = isLong ? currentEntry * 1.01 : currentEntry * 0.99;
                tradeData.sl = isLong ? currentEntry * 0.99 : currentEntry * 1.01;
                console.log('Set default TP/SL values - TP:', tradeData.tp, 'SL:', tradeData.sl);
            }

            console.log('Final trade data:', JSON.stringify(tradeData));
            console.log('Final positionType:', positionType, 'type:', typeof positionType);
            console.log('Final window.positionType:', window.positionType);

            // 캔버스 강제 클리어 및 오버레이 다시 그리기
            if (canvas && ctx) {
                console.log('Clearing canvas before redraw');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }

            // 즉시 오버레이 그리기 (여러 번 시도, 더 긴 간격으로)
            console.log('Scheduling overlay redraws...');
            drawOverlay();
            setTimeout(() => {
                console.log('Redrawing overlay (50ms delay)...');
                drawOverlay();
            }, 50);
            setTimeout(() => {
                console.log('Redrawing overlay (100ms delay)...');
                drawOverlay();
            }, 100);
            setTimeout(() => {
                console.log('Redrawing overlay (200ms delay)...');
                drawOverlay();
            }, 200);
            setTimeout(() => {
                console.log('Redrawing overlay (300ms delay)...');
                drawOverlay();
            }, 300);

            // Android에 업데이트된 가격들 전달
            updateAndroidInputs();

            console.log('=== LINE ADJUSTMENT COMPLETED ===');
        };

        // ========== 초기화 ==========
        function waitForLibrary(callback, maxAttempts = 50) {
            let attempts = 0;
            const checkLibrary = () => {
                attempts++;
                if (typeof LightweightCharts !== 'undefined' &&
                    typeof LightweightCharts.createChart === 'function') {
                    callback();
                } else if (attempts < maxAttempts) {
                    setTimeout(checkLibrary, 100);
                } else {
                    console.error('LightweightCharts library failed to load');
                }
            };
            checkLibrary();
        }

        window.addEventListener('load', () => {
            waitForLibrary(() => {
                console.log('LightweightCharts library loaded successfully');
                initChart();
                initCanvas();

                chartReady = true;
                console.log('Chart ready');

                if (pendingKlines) {
                    console.log('Processing pending klines');
                    window.setOHLCData(pendingKlines);
                    pendingKlines = null;
                }

                // 차트가 완전히 렌더링된 후 오버레이 그리기 (여러 번 시도)
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (first attempt)');
                    drawOverlay();
                }, 500);
                
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (second attempt)');
                    drawOverlay();
                }, 1000);
                
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (third attempt)');
                    drawOverlay();
                }, 2000);

                // 리사이즈 핸들러
                window.addEventListener('resize', () => {
                    if (chart && canvas) {
                        resizeCanvas();
                        setTimeout(() => {
                            drawOverlay();
                        }, 100);
                    }
                });

                // 차트 스케일 변경 시 오버레이 다시 그리기
                if (chart && candlestickSeries) {
                    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
                        setTimeout(() => {
                            drawOverlay();
                        }, 50);
                    });
                }

                if (window.Android && typeof window.Android.onChartReady === 'function') {
                    window.Android.onChartReady();
                }
            });
        });
    </script>
</body>
</html>
