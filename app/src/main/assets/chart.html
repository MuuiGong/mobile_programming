<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>R² Chart - TradingView Lightweight Charts</title>
    <script src="lightweight-charts.standalone.development.js"
            onload="console.log('LightweightCharts script loaded')"
            onerror="console.error('Failed to load LightweightCharts script')"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #1A1F2E;
            overflow: hidden;
            padding-bottom: env(safe-area-inset-bottom);
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }

        #container {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            padding-left: 8px;
            padding-right: 8px;
        }

        .top-bar {
            background-color: #1C1F26;
            border-bottom: 1px solid #2D3139;
            padding: 12px 16px;
            padding-top: calc(12px + env(safe-area-inset-top));
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 100;
        }

        .coin-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .coin-name {
            font-size: 14px;
            font-weight: 600;
            color: #E1E8ED;
        }

        .current-price {
            font-size: 16px;
            font-weight: 600;
            color: #26a69a;
        }

        .price-change {
            font-size: 12px;
            color: #26a69a;
        }

        #chart-container {
            flex: 1;
            background-color: #1A1F2E;
            position: relative;
            overflow: hidden;
            margin: 8px 0;
            border-radius: 8px;
        }

        #chart {
            width: 100%;
            height: 100%;
        }

        /* 오버레이 캔버스 */
        #overlay-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1000;
            pointer-events: auto;  /* 이벤트 감지를 위해 활성화 */
            touch-action: none;
            background: transparent;
        }

        /* 차트 하단 시간 표시 */
        #update-time-display {
            position: absolute;
            bottom: 4px;
            right: 8px;
            z-index: 1500;
            pointer-events: none;
            display: block;
            text-align: right;
        }
        
        #update-time-display .time-value {
            color: #888;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.2px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="container">
        <div class="top-bar">
            <div class="coin-info">
                <span class="coin-name" id="coinName">BTCUSDT</span>
                <span class="current-price" id="currentPrice">--</span>
                <span class="price-change" id="priceChange">--</span>
            </div>
        </div>
        <div id="chart-container">
            <div id="chart"></div>
            <canvas id="overlay-canvas"></canvas>
            <!-- 차트 하단 타임스케일 옆 시간 표시 -->
            <div id="update-time-display">
                <span class="time-value" id="updateTime">--:--:--</span>
            </div>
        </div>
    </div>

    <script>
        console.log('===== CHART.HTML LOADED =====');
        console.log('Script started executing');

        // ========== 거래 데이터 ==========
        let tradeData = {
            entry: null,
            tp: null,
            sl: null,
            liquidationPrice: null, // 청산 예산가
            currentPrice: null,
            basePrice: null
        };

        let positionType = 'long'; // 'long' or 'short'
        let chart = null;
        let candlestickSeries = null;
        let volumeSeries = null;
        let chartReady = false;
        let pendingKlines = null;
        
        // 실시간 업데이트 시간 추적
        let lastUpdateTime = null;
        let lastCandleTime = null;

        // 오버레이 캔버스
        let canvas = null;
        let ctx = null;
        let isDragging = false;
        let dragTarget = null; // 'ep', 'tp', 'sl'

        // ========== Lightweight Charts 초기화 ==========
        function initChart() {
            const chartContainer = document.getElementById('chart');

            if (!chartContainer) {
                console.error('Chart container not found');
                return;
            }

            if (typeof LightweightCharts === 'undefined' || !LightweightCharts.createChart) {
                console.error('LightweightCharts library is not available');
                return;
            }

            const containerWidth = chartContainer.clientWidth || chartContainer.offsetWidth || 800;
            const containerHeight = chartContainer.clientHeight || chartContainer.offsetHeight || 600;

            console.log('Initializing chart with size:', containerWidth, 'x', containerHeight);

            chart = LightweightCharts.createChart(chartContainer, {
                width: containerWidth,
                height: containerHeight,
                layout: {
                    background: { color: '#1A1F2E' },
                    textColor: '#888',
                },
                grid: {
                    vertLines: { color: '#2D3139' },
                    horzLines: { color: '#2D3139' },
                },
                crosshair: {
                    mode: LightweightCharts.CrosshairMode.Normal,
                },
                rightPriceScale: {
                    borderColor: '#252830',
                },
                timeScale: {
                    borderColor: '#252830',
                    timeVisible: true,
                    secondsVisible: false,
                },
            });

            if (!chart) {
                console.error('Failed to create chart');
                return;
            }

            // 캔들스틱 시리즈
            console.log('Available methods on chart:', Object.keys(chart));

            // v4.x API 시도
            if (chart.addCandlestickSeries) {
                console.log('Using v4.x addCandlestickSeries');
                candlestickSeries = chart.addCandlestickSeries({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                    borderUpColor: '#26a69a',
                    borderDownColor: '#ef5350',
                    wickUpColor: '#26a69a',
                    wickDownColor: '#ef5350',
                });
            }
            // v3.x API 시도
            else if (chart.addCandle) {
                console.log('Using v3.x addCandle');
                candlestickSeries = chart.addCandle({
                    upColor: '#26a69a',
                    downColor: '#ef5350',
                });
            }
            else {
                console.error('No suitable API found for creating candlestick series');
                console.error('LightweightCharts version might be incompatible');
                return;
            }

            console.log('Candlestick series created:', candlestickSeries);

            // 캔들스틱 price scale에 scaleMargins 설정
            try {
                const rightPriceScale = chart.priceScale('right');
                if (rightPriceScale) {
                    rightPriceScale.applyOptions({
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.3,  // 하단 30%는 볼륨용으로 확보
                        },
                    });
                }
            } catch (e) {
                console.warn('Could not configure right price scale:', e);
            }

            // 볼륨 시리즈 (별도 price scale로 분리하여 하단에 배치)
            if (chart.addHistogramSeries) {
                volumeSeries = chart.addHistogramSeries({
                    color: '#26a69a',
                    priceFormat: {
                        type: 'volume',
                    },
                    priceScaleId: 'volume',
                });
                console.log('Volume series created successfully');
                
                // 볼륨 price scale 설정
                try {
                    const volumePriceScale = chart.priceScale('volume');
                    if (volumePriceScale) {
                        volumePriceScale.applyOptions({
                            visible: false,  // 볼륨 스케일 라벨 숨김
                            scaleMargins: {
                                top: 0.7,   // 상단 70% 여백 (캔들스틱 영역 확보)
                                bottom: 0,  // 하단 여백 없음
                            },
                        });
                    }
                } catch (e) {
                    console.warn('Could not configure volume price scale:', e);
                }
            }

            // 샘플 데이터 생성 제거 - 실시간 데이터만 사용
            // generateSampleData();

            // 리사이즈 핸들러
            window.addEventListener('resize', () => {
                if (chart && chartContainer) {
                    const newWidth = chartContainer.clientWidth || chartContainer.offsetWidth;
                    const newHeight = chartContainer.clientHeight || chartContainer.offsetHeight;
                    if (newWidth > 0 && newHeight > 0) {
                        chart.resize(newWidth, newHeight);
                    }
                }
            });

            console.log('Chart initialization completed');
        }

        // ========== 샘플 데이터 생성 함수 제거됨 - 실시간 데이터만 사용 ==========
        /*
        function generateSampleData() {
            // Mock 데이터 생성 함수 - 제거됨
        }
        */

        // ========== 오버레이 캔버스 초기화 ==========
        function initCanvas() {
            canvas = document.getElementById('overlay-canvas');
            if (!canvas) {
                console.error('overlay-canvas element not found');
                return;
            }
            
            ctx = canvas.getContext('2d');
            if (!ctx) {
                console.error('Failed to get 2d context');
                return;
            }

            resizeCanvas();

            // 이벤트 리스너
            canvas.addEventListener('mousedown', handleStart);
            canvas.addEventListener('mousemove', handleMove);
            canvas.addEventListener('mouseup', handleEnd);
            canvas.addEventListener('touchstart', handleStart, { passive: false });
            canvas.addEventListener('touchmove', handleMove, { passive: false });
            canvas.addEventListener('touchend', handleEnd);
            
            console.log('Canvas initialized, canvas:', !!canvas, 'ctx:', !!ctx);
            
            // 캔버스 초기화 후 오버레이 그리기 시도
            setTimeout(() => {
                drawOverlay();
                console.log('Initial overlay drawn after canvas init');
            }, 100);
        }

        function resizeCanvas() {
            if (!canvas) {
                console.warn('resizeCanvas: canvas not initialized');
                return;
            }
            
            const container = document.getElementById('chart-container');
            if (!container) {
                console.warn('resizeCanvas: chart-container not found');
                return;
            }
            
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
        }

        // ========== 오버레이 그리기 ==========
        function drawOverlay() {
            console.log('=== drawOverlay called ===');
            
            if (!canvas || !ctx || !candlestickSeries) {
                console.error('drawOverlay: Missing components', {
                    canvas: !!canvas,
                    ctx: !!ctx,
                    candlestickSeries: !!candlestickSeries
                });
                return;
            }

            // 캔버스 크기 확인 및 업데이트
            const container = document.getElementById('chart-container');
            if (!container) {
                console.error('drawOverlay: chart-container not found');
                return;
            }
            
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;
            
            console.log('Container size:', containerWidth, 'x', containerHeight);
            
            if (canvas.width !== containerWidth || canvas.height !== containerHeight) {
                canvas.width = containerWidth;
                canvas.height = containerHeight;
                console.log('Canvas resized to:', canvas.width, 'x', canvas.height);
            }

            if (canvas.width === 0 || canvas.height === 0) {
                console.warn('drawOverlay: Canvas size is 0, retrying...');
                setTimeout(() => drawOverlay(), 100);
                return;
            }

            // 캔버스가 보이도록 강제
            canvas.style.display = 'block';
            canvas.style.visibility = 'visible';
            canvas.style.opacity = '1';

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (!candlestickSeries) {
                console.warn('drawOverlay: candlestickSeries not available, retrying...');
                setTimeout(() => {
                    if (candlestickSeries) {
                        drawOverlay();
                    }
                }, 100);
                return;
            }
            
            // 가격 스케일 영역 너비 추정 (오른쪽 가격 스케일이 차지하는 공간)
            // Lightweight Charts에서 가격 스케일은 보통 50-80px 정도 차지
            const priceScaleWidth = 80; // 가격 스케일 영역 너비 (조정 가능)
            const lineEndX = canvas.width - priceScaleWidth; // 라인이 끝나는 X 좌표

            // priceToCoordinate는 candlestickSeries에서 직접 호출해야 함
            if (typeof candlestickSeries.priceToCoordinate !== 'function') {
                console.warn('drawOverlay: priceToCoordinate method not available, retrying...');
                setTimeout(() => {
                    if (candlestickSeries && typeof candlestickSeries.priceToCoordinate === 'function') {
                        drawOverlay();
                    }
                }, 100);
                return;
            }

            console.log('Trade data:', tradeData);

            // EP, TP, SL 값이 있는지 확인
            if (tradeData.entry === null && tradeData.tp === null && tradeData.sl === null) {
                console.warn('drawOverlay: No trade data to draw');
                return;
            }

            // EP-TP 영역 색칠
            if (tradeData.entry !== null && tradeData.tp !== null) {
                try {
                    const epY = candlestickSeries.priceToCoordinate(tradeData.entry);
                    const tpY = candlestickSeries.priceToCoordinate(tradeData.tp);
                    
                    if (epY !== null && epY !== undefined && !isNaN(epY) &&
                        tpY !== null && tpY !== undefined && !isNaN(tpY) &&
                        epY >= 0 && epY <= canvas.height &&
                        tpY >= 0 && tpY <= canvas.height) {
                        ctx.fillStyle = positionType === 'long' ? 'rgba(38, 166, 154, 0.1)' : 'rgba(239, 83, 80, 0.1)';
                        ctx.fillRect(0, Math.min(epY, tpY), lineEndX, Math.abs(tpY - epY));
                    }
                } catch (e) {
                    console.error('Error drawing EP-TP area:', e);
                }
            }

            // EP-SL 영역 색칠
            if (tradeData.entry !== null && tradeData.sl !== null) {
                try {
                    const epY = candlestickSeries.priceToCoordinate(tradeData.entry);
                    const slY = candlestickSeries.priceToCoordinate(tradeData.sl);
                    
                    if (epY !== null && epY !== undefined && !isNaN(epY) &&
                        slY !== null && slY !== undefined && !isNaN(slY) &&
                        epY >= 0 && epY <= canvas.height &&
                        slY >= 0 && slY <= canvas.height) {
                        ctx.fillStyle = positionType === 'long' ? 'rgba(239, 83, 80, 0.1)' : 'rgba(38, 166, 154, 0.1)';
                        ctx.fillRect(0, Math.min(epY, slY), lineEndX, Math.abs(slY - epY));
                    }
                } catch (e) {
                    console.error('Error drawing EP-SL area:', e);
                }
            }

            // 모든 라인의 y 좌표 계산
            let epY = null, tpY = null, slY = null, lpY = null;
            
            if (tradeData.entry !== null && tradeData.entry > 0) {
                try {
                    epY = candlestickSeries.priceToCoordinate(tradeData.entry);
                } catch (e) {
                    console.error('Error calculating EP coordinate:', e);
                }
            }
            
            if (tradeData.tp !== null && tradeData.tp > 0) {
                try {
                    tpY = candlestickSeries.priceToCoordinate(tradeData.tp);
                } catch (e) {
                    console.error('Error calculating TP coordinate:', e);
                }
            }
            
            if (tradeData.sl !== null && tradeData.sl > 0) {
                try {
                    slY = candlestickSeries.priceToCoordinate(tradeData.sl);
                } catch (e) {
                    console.error('Error calculating SL coordinate:', e);
                }
            }
            
            if (tradeData.liquidationPrice !== null && tradeData.liquidationPrice > 0) {
                try {
                    lpY = candlestickSeries.priceToCoordinate(tradeData.liquidationPrice);
                } catch (e) {
                    console.error('Error calculating LP coordinate:', e);
                }
            }

            // 각 라인 쌍이 겹치는지 개별적으로 확인 (5픽셀 이내면 겹침으로 간주)
            const threshold = 5;
            const epTpOverlap = epY !== null && tpY !== null && Math.abs(epY - tpY) < threshold;
            const epSlOverlap = epY !== null && slY !== null && Math.abs(epY - slY) < threshold;
            const tpSlOverlap = tpY !== null && slY !== null && Math.abs(tpY - slY) < threshold;
            
            // EP 라인과 버튼들
            if (epY !== null && !isNaN(epY)) {
                if (epY >= -100 && epY <= canvas.height + 100) {
                    // EP 라인 그리기 (가격 스케일 영역을 피함)
                    ctx.strokeStyle = '#2962FF';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, epY);
                    ctx.lineTo(lineEndX, epY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // EP 라인에 버튼 표시
                    const buttonWidth = 32;
                    const buttonHeight = 20;
                    const spacing = 5;
                    const startX = 10;
                    const buttonY = epY - buttonHeight / 2;
                    
                    // EP 버튼 (항상 표시)
                    drawButton(startX, buttonY, buttonWidth, buttonHeight, '#2962FF', 'EP');
                    
                    // TP 버튼 (TP가 EP와 겹치거나 TP가 없을 때만 EP 라인에 표시)
                    if (epTpOverlap || (tradeData.tp === null || tradeData.tp === 0)) {
                        drawButton(startX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight, '#26a69a', 'TP');
                    }
                    
                    // SL 버튼 (SL이 EP와 겹치거나 SL이 없을 때만 EP 라인에 표시)
                    if (epSlOverlap || (tradeData.sl === null || tradeData.sl === 0)) {
                        drawButton(startX + (buttonWidth + spacing) * 2, buttonY, buttonWidth, buttonHeight, '#ef5350', 'SL');
                    }
                }
            }

            // TP 라인과 TP 버튼 (EP와 겹치지 않을 때만)
            if (tpY !== null && !isNaN(tpY) && !epTpOverlap) {
                if (tpY >= -100 && tpY <= canvas.height + 100) {
                    drawLineWithButton(tpY, '#26a69a', 'TP');
                }
            }

            // SL 라인과 SL 버튼 (EP와 겹치지 않을 때만)
            if (slY !== null && !isNaN(slY) && !epSlOverlap) {
                if (slY >= -100 && slY <= canvas.height + 100) {
                    drawLineWithButton(slY, '#ef5350', 'SL');
                }
            }
            
            // LP 라인과 LP 버튼 (청산 예산가 - 노란색 점선)
            if (lpY !== null && !isNaN(lpY)) {
                if (lpY >= -100 && lpY <= canvas.height + 100) {
                    // LP는 항상 점선으로 표시
                    ctx.strokeStyle = '#FFC107'; // 노란색
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(0, lpY);
                    ctx.lineTo(lineEndX, lpY);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // LP 버튼 표시 (오른쪽에 배치)
                    const buttonWidth = 32;
                    const buttonHeight = 20;
                    const endX = lineEndX - buttonWidth - 10; // 오른쪽에서 10px 여백
                    const buttonY = lpY - buttonHeight / 2;
                    drawButton(endX, buttonY, buttonWidth, buttonHeight, '#FFC107', 'LP');
                }
            }
            
            console.log('=== drawOverlay completed ===');
        }

        function drawLineWithButton(y, color, label) {
            if (!ctx || !canvas) {
                console.error('drawLineWithButton: ctx or canvas not available');
                return;
            }
            
            // 가격 스케일 영역 너비 추정
            const priceScaleWidth = 80;
            const lineEndX = canvas.width - priceScaleWidth;
            
            // 가로선 그리기 (가격 스케일 영역을 피함)
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            
            if (label === 'EP') {
                // EP는 점선
                ctx.setLineDash([5, 5]);
            } else {
                // TP, SL은 실선
                ctx.setLineDash([]);
            }
            
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(lineEndX, y);
            ctx.stroke();
            ctx.setLineDash([]);

            // 버튼을 라인 중앙에 위치
            const buttonWidth = 32;
            const buttonHeight = 20;
            const startX = 10;
            const buttonY = y - buttonHeight / 2; // 라인 중앙에 버튼 위치

            // 해당 라인의 버튼만 그리기
            drawButton(startX, buttonY, buttonWidth, buttonHeight, color, label);
        }

        function drawButtonsOnEPLine(y) {
            if (!ctx || !canvas) return;
            
            const buttonWidth = 32;
            const buttonHeight = 20;
            const spacing = 5;
            const startX = 10;
            const buttonY = y - buttonHeight / 2;

            // EP 버튼 (항상 표시)
            drawButton(startX, buttonY, buttonWidth, buttonHeight, '#2962FF', 'EP');

            // TP 버튼 (항상 표시 - 선들이 겹칠 때)
            drawButton(startX + buttonWidth + spacing, buttonY, buttonWidth, buttonHeight, '#26a69a', 'TP');

            // SL 버튼 (항상 표시 - 선들이 겹칠 때)
            drawButton(startX + (buttonWidth + spacing) * 2, buttonY, buttonWidth, buttonHeight, '#ef5350', 'SL');
        }

        function drawLineOnly(y, color) {
            if (!ctx || !canvas) {
                console.error('drawLineOnly: ctx or canvas not available');
                return;
            }
            
            // 가격 스케일 영역 너비 추정
            const priceScaleWidth = 80;
            const lineEndX = canvas.width - priceScaleWidth;
            
            // 가로선 (실선) - TP, SL 라인 (가격 스케일 영역을 피함)
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.setLineDash([]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(lineEndX, y);
            ctx.stroke();
        }

        function drawLine(y, color, label) {
            if (!ctx || !canvas) {
                console.error('drawLine: ctx or canvas not available');
                return;
            }
            
            // 가격 스케일 영역 너비 추정
            const priceScaleWidth = 80;
            const lineEndX = canvas.width - priceScaleWidth;
            
            // 가로선 (점선) (가격 스케일 영역을 피함)
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;  // 더 두껍게
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(lineEndX, y);
            ctx.stroke();
            ctx.setLineDash([]);

            // 라벨 (TP, SL 라인용)
            drawButton(10, y - 12, 40, 24, color, label);
        }

        function drawButton(x, y, width, height, color, text) {
            if (!ctx) {
                console.error('drawButton: ctx not available');
                return;
            }
            
            const borderRadius = 5; // 모서리 둥글기 (버튼 크기에 맞게 조정)
            
            // 둥근 모서리 사각형 경로 생성
            ctx.beginPath();
            ctx.moveTo(x + borderRadius, y);
            ctx.lineTo(x + width - borderRadius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + borderRadius);
            ctx.lineTo(x + width, y + height - borderRadius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - borderRadius, y + height);
            ctx.lineTo(x + borderRadius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - borderRadius);
            ctx.lineTo(x, y + borderRadius);
            ctx.quadraticCurveTo(x, y, x + borderRadius, y);
            ctx.closePath();
            
            // 배경색 (차트 색상: #1A1F2E, RGB 26, 31, 46)
            ctx.fillStyle = '#1A1F2E';
            ctx.fill();
            
            // 테두리 (색상 적용)
            ctx.strokeStyle = color;
            ctx.lineWidth = 1.5;
            ctx.stroke();
            
            // 텍스트 (색상 적용)
            ctx.fillStyle = color;
            ctx.font = 'bold 10px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x + width / 2, y + height / 2);
        }

        // ========== 현재가 업데이트 ==========
        function updateCurrentPrice(price) {
            if (tradeData.basePrice === null || tradeData.basePrice === 0) {
                tradeData.basePrice = price;
            }

            tradeData.currentPrice = price;

            document.getElementById('currentPrice').textContent = `$${price.toFixed(2)}`;

            const change = ((price - tradeData.basePrice) / tradeData.basePrice * 100).toFixed(2);
            const changeElement = document.getElementById('priceChange');
            changeElement.textContent = `${change >= 0 ? '+' : ''}${change}%`;
            changeElement.style.color = change >= 0 ? '#26a69a' : '#ef5350';

            drawOverlay();
        }

        // ========== 드래그 이벤트 핸들러 ==========
        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function getButtonAtPos(x, y) {
            if (!candlestickSeries) return null;

            if (typeof candlestickSeries.priceToCoordinate !== 'function') return null;

            const buttonWidth = 40;
            const buttonHeight = 24;
            const spacing = 5;
            const startX = 10;

            // 모든 라인의 y 좌표 계산
            let epY = null, tpY = null, slY = null;
            
            if (tradeData.entry !== null && tradeData.entry > 0) {
                epY = candlestickSeries.priceToCoordinate(tradeData.entry);
            }
            if (tradeData.tp !== null && tradeData.tp > 0) {
                tpY = candlestickSeries.priceToCoordinate(tradeData.tp);
            }
            if (tradeData.sl !== null && tradeData.sl > 0) {
                slY = candlestickSeries.priceToCoordinate(tradeData.sl);
            }

            // 각 라인 쌍이 겹치는지 개별적으로 확인
            const threshold = 5;
            const epTpOverlap = epY !== null && tpY !== null && Math.abs(epY - tpY) < threshold;
            const epSlOverlap = epY !== null && slY !== null && Math.abs(epY - slY) < threshold;

            // TP 버튼 체크 (TP 라인에 있는 버튼, EP와 겹치지 않을 때만)
            if (tpY !== null && !isNaN(tpY) && !epTpOverlap) {
                const buttonY = tpY - buttonHeight / 2;
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'tp';
                }
            }

            // SL 버튼 체크 (SL 라인에 있는 버튼, EP와 겹치지 않을 때만)
            if (slY !== null && !isNaN(slY) && !epSlOverlap) {
                const buttonY = slY - buttonHeight / 2;
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'sl';
                }
            }

            // EP 라인에 있는 버튼들 체크
            if (epY !== null && !isNaN(epY)) {
                const buttonY = epY - buttonHeight / 2;

                // EP 버튼 체크
                if (x >= startX && x <= startX + buttonWidth &&
                    y >= buttonY && y <= buttonY + buttonHeight) {
                    return 'ep';
                }

                // TP 버튼 체크 (EP와 겹치거나 TP 라인이 없을 때 EP 라인에 있음)
                if (epTpOverlap || (tradeData.tp === null || tradeData.tp === 0)) {
                    if (x >= startX + buttonWidth + spacing && x <= startX + (buttonWidth + spacing) * 2 &&
                        y >= buttonY && y <= buttonY + buttonHeight) {
                        return 'tp';
                    }
                }

                // SL 버튼 체크 (EP와 겹치거나 SL 라인이 없을 때 EP 라인에 있음)
                if (epSlOverlap || (tradeData.sl === null || tradeData.sl === 0)) {
                    if (x >= startX + (buttonWidth + spacing) * 2 && x <= startX + (buttonWidth + spacing) * 3 &&
                        y >= buttonY && y <= buttonY + buttonHeight) {
                        return 'sl';
                    }
                }
            }

            return null;
        }

        function handleStart(e) {
            const pos = getPointerPos(e);
            const button = getButtonAtPos(pos.x, pos.y);

            if (button) {
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                dragTarget = button;
                console.log('Drag started:', button);
            } else {
                // 버튼이 아닌 곳을 클릭하면 차트 이벤트로 전달
                // 이벤트를 막지 않고 캔버스를 일시적으로 투과시켜 차트가 직접 이벤트를 받도록 함
                if (canvas) {
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    
                    // 캔버스를 일시적으로 투과시킴
                    canvas.style.pointerEvents = 'none';
                    
                    // 즉시 차트 요소에 이벤트 전달
                    setTimeout(() => {
                        const elementBelow = document.elementFromPoint(clientX, clientY);
                        if (elementBelow && elementBelow !== canvas) {
                            // 마우스 이벤트로 변환하여 전달 (가장 호환성이 좋음)
                            const mouseEvent = new MouseEvent('mousedown', {
                                bubbles: true,
                                cancelable: true,
                                clientX: clientX,
                                clientY: clientY,
                                button: e.touches ? 0 : e.button,
                                buttons: e.touches ? 1 : e.buttons,
                                view: window
                            });
                            
                            elementBelow.dispatchEvent(mouseEvent);
                            
                            // 터치 이벤트도 전달 시도 (지원되는 경우)
                            if (e.touches) {
                                setTimeout(() => {
                                    try {
                                        const touchEvent = new TouchEvent('touchstart', {
                                            bubbles: true,
                                            cancelable: true,
                                            touches: e.touches,
                                            targetTouches: e.touches,
                                            changedTouches: e.touches
                                        });
                                        elementBelow.dispatchEvent(touchEvent);
                                    } catch (err) {
                                        // TouchEvent가 지원되지 않는 경우 무시
                                    }
                                }, 0);
                            }
                        }
                        
                        // 짧은 시간 후 캔버스 다시 활성화
                        setTimeout(() => {
                            if (canvas) {
                                canvas.style.pointerEvents = 'auto';
                            }
                        }, 100);
                    }, 0);
                }
            }
        }

        function handleMove(e) {
            if (!isDragging || !dragTarget || !candlestickSeries) return;

            e.preventDefault();
            e.stopPropagation();
            const pos = getPointerPos(e);
            
            if (typeof candlestickSeries.coordinateToPrice !== 'function') {
                console.warn('coordinateToPrice not available');
                return;
            }

            let price = candlestickSeries.coordinateToPrice(pos.y);
            if (price === null || price === undefined || isNaN(price)) {
                console.warn('Invalid price:', price, 'y:', pos.y);
                return;
            }
            
            console.log('Dragging:', dragTarget, 'price:', price);

            // 가격 제한 로직
            if (dragTarget === 'ep') {
                // EP는 TP와 SL 사이에 있어야 함
                if (positionType === 'long') {
                    // 롱: SL < EP < TP
                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        price = Math.max(price, tradeData.sl);
                    }
                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        price = Math.min(price, tradeData.tp);
                    }
                } else {
                    // 숏: TP < EP < SL
                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        price = Math.max(price, tradeData.tp);
                    }
                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        price = Math.min(price, tradeData.sl);
                    }
                }
                tradeData.entry = price;
            } else if (dragTarget === 'tp') {
                if (tradeData.entry === null || tradeData.entry === 0) {
                    // EP가 없으면 제한 없음
                    tradeData.tp = price;
                } else {
                    if (positionType === 'long') {
                        // 롱: TP는 진입가보다 낮아질 수 없음
                        price = Math.max(price, tradeData.entry);
                    } else {
                        // 숏: TP는 진입가보다 높아질 수 없음
                        price = Math.min(price, tradeData.entry);
                    }
                    tradeData.tp = price;
                }
            } else if (dragTarget === 'sl') {
                if (tradeData.entry === null || tradeData.entry === 0) {
                    // EP가 없으면 제한 없음
                    tradeData.sl = price;
                } else {
                    if (positionType === 'long') {
                        // 롱: SL은 진입가보다 높아질 수 없음
                        price = Math.min(price, tradeData.entry);
                    } else {
                        // 숏: SL은 진입가보다 낮아질 수 없음
                        price = Math.max(price, tradeData.entry);
                    }
                    tradeData.sl = price;
                }
            }

            drawOverlay();
            
            // Android에 가격 업데이트 전달 (드래그 중에도 실시간 업데이트)
            updateAndroidInputs();
        }

        function updateAndroidInputs() {
            // Android WebView에 가격 업데이트 전달 (개별 메서드 호출)
            console.log('updateAndroidInputs called:', { 
                entry: tradeData.entry, 
                tp: tradeData.tp, 
                sl: tradeData.sl 
            });
            
            if (window.Android) {
                try {
                    // Entry 가격 업데이트
                    if (tradeData.entry !== null && tradeData.entry > 0) {
                        if (typeof window.Android.onEntryPriceChanged === 'function') {
                            window.Android.onEntryPriceChanged(tradeData.entry);
                            console.log('onEntryPriceChanged called with:', tradeData.entry);
                        }
                    }
                    
                    // TP 가격 업데이트
                    if (tradeData.tp !== null && tradeData.tp > 0) {
                        if (typeof window.Android.onTakeProfitChanged === 'function') {
                            window.Android.onTakeProfitChanged(tradeData.tp);
                            console.log('onTakeProfitChanged called with:', tradeData.tp);
                        }
                    }
                    
                    // SL 가격 업데이트
                    if (tradeData.sl !== null && tradeData.sl > 0) {
                        if (typeof window.Android.onStopLossChanged === 'function') {
                            window.Android.onStopLossChanged(tradeData.sl);
                            console.log('onStopLossChanged called with:', tradeData.sl);
                        }
                    }
                } catch (e) {
                    console.error('Error calling Android methods:', e);
                }
            } else {
                console.warn('window.Android is not available');
            }
        }

        function handleEnd(e) {
            if (isDragging) {
                e.preventDefault();
                e.stopPropagation();
                console.log('Drag ended');
                isDragging = false;
                dragTarget = null;
                // Android에 최종 가격 업데이트 전달
                updateAndroidInputs();
            }
        }

        // ========== Binance OHLC 데이터 설정 ==========
        window.setOHLCData = function(klines) {
            console.log('===== setOHLCData called =====');
            console.log('Klines count:', klines ? klines.length : 0);

            if (!klines || klines.length === 0) {
                console.warn('No OHLC data provided');
                return;
            }

            if (!chartReady || !candlestickSeries) {
                console.warn('Chart not ready yet, storing klines for later');
                pendingKlines = klines;
                return;
            }

            try {
                const candleData = [];
                const volumeData = [];

                for (let i = 0; i < klines.length; i++) {
                    const kline = klines[i];
                    if (kline && kline.length >= 6) {
                        const openTime = Math.floor(kline[0] / 1000);
                        const open = parseFloat(kline[1]);
                        const high = parseFloat(kline[2]);
                        const low = parseFloat(kline[3]);
                        const close = parseFloat(kline[4]);
                        const volume = parseFloat(kline[5]);

                        candleData.push({
                            time: openTime,
                            open: open,
                            high: high,
                            low: low,
                            close: close
                        });

                        volumeData.push({
                            time: openTime,
                            value: volume,
                            color: close > open ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                        });
                    }
                }

                candlestickSeries.setData(candleData);
                if (volumeSeries && volumeData.length > 0) {
                    volumeSeries.setData(volumeData);
                }

                // 데이터 설정 후 scaleMargins 다시 적용하여 분리 보장
                if (candlestickSeries) {
                    candlestickSeries.applyOptions({
                        scaleMargins: {
                            top: 0.1,
                            bottom: 0.3,  // 하단 30%는 볼륨용으로 확보
                        },
                    });
                }
                if (volumeSeries) {
                    volumeSeries.applyOptions({
                        scaleMargins: {
                            top: 0.7,   // 상단 70% 여백 (캔들스틱 영역 확보)
                            bottom: 0,  // 하단 여백 없음
                        },
                    });
                }

                if (chart && candleData.length > 0) {
                    chart.timeScale().fitContent();
                }

                if (candleData.length > 0) {
                    const lastCandle = candleData[candleData.length - 1];
                    lastCandleTime = lastCandle.time;
                    updateCurrentPrice(lastCandle.close);
                    updateTimeDisplay();

                    // EP만 자동 초기화 (TP, SL은 나중에 드래그로 설정)
                    if (tradeData.entry === null) {
                        tradeData.entry = lastCandle.close;
                        tradeData.tp = null;  // 처음에는 TP 없음
                        tradeData.sl = null;  // 처음에는 SL 없음

                        console.log('Auto-initialized EP only from OHLC data:', {
                            entry: tradeData.entry
                        });
                    }
                    
                    // 오버레이 다시 그리기 (여러 번 시도)
                    setTimeout(() => {
                        drawOverlay();
                    }, 200);
                    setTimeout(() => {
                        drawOverlay();
                    }, 500);
                    setTimeout(() => {
                        drawOverlay();
                    }, 1000);
                }
            } catch (error) {
                console.error('Error setting OHLC data:', error);
            }
        };

        // ========== 실시간 캔들 업데이트 ==========
        window.updateKline = function(openTime, open, high, low, close, volume) {
            if (!candlestickSeries) return;

            try {
                const time = Math.floor(openTime / 1000);
                lastCandleTime = time;
                lastUpdateTime = new Date();

                candlestickSeries.update({
                    time: time,
                    open: parseFloat(open),
                    high: parseFloat(high),
                    low: parseFloat(low),
                    close: parseFloat(close)
                });

                if (volumeSeries) {
                    volumeSeries.update({
                        time: time,
                        value: parseFloat(volume),
                        color: parseFloat(close) > parseFloat(open) ? 'rgba(38, 166, 154, 0.5)' : 'rgba(239, 83, 80, 0.5)'
                    });
                }

                updateCurrentPrice(parseFloat(close));
                updateTimeDisplay();
            } catch (error) {
                console.error('Error updating kline:', error);
            }
        };
        
        // ========== 실시간 가격 업데이트 ==========
        window.setCurrentPrice = function(price) {
            if (!candlestickSeries) return;
            
            try {
                lastUpdateTime = new Date();
                
                // 마지막 캔들 시간 가져오기
                if (lastCandleTime === null) {
                    const data = candlestickSeries.data();
                    if (data && data.length > 0) {
                        lastCandleTime = data[data.length - 1].time;
                    }
                }
                
                // 마지막 캔들 업데이트
                if (lastCandleTime !== null) {
                    const lastCandle = candlestickSeries.dataByIndex(candlestickSeries.data().length - 1);
                    if (lastCandle) {
                        candlestickSeries.update({
                            time: lastCandleTime,
                            open: lastCandle.open,
                            high: Math.max(lastCandle.high, parseFloat(price)),
                            low: Math.min(lastCandle.low, parseFloat(price)),
                            close: parseFloat(price)
                        });
                    }
                }
                
                updateCurrentPrice(parseFloat(price));
                updateTimeDisplay();
            } catch (error) {
                console.error('Error setting current price:', error);
            }
        };
        
        // ========== 시간 표시 업데이트 ==========
        function updateTimeDisplay() {
            const timeDisplayContainer = document.getElementById('update-time-display');
            const timeDisplay = document.getElementById('updateTime');
            if (!timeDisplayContainer || !timeDisplay) {
                console.warn('Time display elements not found');
                return;
            }
            
            let timeText = '';
            if (lastUpdateTime) {
                const hours = lastUpdateTime.getHours().toString().padStart(2, '0');
                const minutes = lastUpdateTime.getMinutes().toString().padStart(2, '0');
                const seconds = lastUpdateTime.getSeconds().toString().padStart(2, '0');
                timeText = `${hours}:${minutes}:${seconds}`;
            } else if (lastCandleTime) {
                const date = new Date(lastCandleTime * 1000);
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes().toString().padStart(2, '0');
                const seconds = date.getSeconds().toString().padStart(2, '0');
                timeText = `${hours}:${minutes}:${seconds}`;
            } else {
                // 기본값으로 현재 시간 표시
                const now = new Date();
                const hours = now.getHours().toString().padStart(2, '0');
                const minutes = now.getMinutes().toString().padStart(2, '0');
                const seconds = now.getSeconds().toString().padStart(2, '0');
                timeText = `${hours}:${minutes}:${seconds}`;
            }
            
            if (timeText) {
                timeDisplay.textContent = timeText;
                timeDisplayContainer.style.display = 'block';
                console.log('Time display updated:', timeText);
            } else {
                timeDisplay.textContent = '--:--:--';
                timeDisplayContainer.style.display = 'block'; // 항상 표시
            }
        }

        // ========== Android 인터페이스 ==========
        // Android에서 호출하는 함수 (updateLines로도 호출 가능)
        window.updateLines = function(entry, tp, sl) {
            console.log('updateLines called (alias for updateTradeData):', { entry, tp, sl });
            window.updateTradeData(entry, tp, sl);
        };
        
        window.updateTradeData = function(entry, tp, sl) {
            console.log('===== updateTradeData called =====');
            console.log('Parameters:', { entry, tp, sl });
            console.log('Current tradeData before update:', JSON.parse(JSON.stringify(tradeData)));
            
            let updated = false;
            
            if (entry !== undefined && entry !== null && entry !== '') {
                const entryValue = parseFloat(entry);
                if (!isNaN(entryValue) && entryValue > 0) {
                    if (tradeData.entry !== entryValue) {
                        tradeData.entry = entryValue;
                        updated = true;
                        console.log('Entry updated to:', entryValue);
                    }
                } else if (entry === '' || entry === '0' || entry === '0.00') {
                    if (tradeData.entry !== null) {
                        tradeData.entry = null;
                        updated = true;
                        console.log('Entry cleared');
                    }
                }
            }
            
            if (tp !== undefined && tp !== null && tp !== '') {
                const tpValue = parseFloat(tp);
                if (!isNaN(tpValue) && tpValue > 0) {
                    if (tradeData.tp !== tpValue) {
                        tradeData.tp = tpValue;
                        updated = true;
                        console.log('TP updated to:', tpValue);
                    }
                } else if (tp === '' || tp === '0' || tp === '0.00') {
                    if (tradeData.tp !== null) {
                        tradeData.tp = null;
                        updated = true;
                        console.log('TP cleared');
                    }
                }
            }
            
            if (sl !== undefined && sl !== null && sl !== '') {
                const slValue = parseFloat(sl);
                if (!isNaN(slValue) && slValue > 0) {
                    if (tradeData.sl !== slValue) {
                        tradeData.sl = slValue;
                        updated = true;
                        console.log('SL updated to:', slValue);
                    }
                } else if (sl === '' || sl === '0' || sl === '0.00') {
                    if (tradeData.sl !== null) {
                        tradeData.sl = null;
                        updated = true;
                        console.log('SL cleared');
                    }
                }
            }
            
            if (updated) {
                console.log('Updated tradeData:', JSON.parse(JSON.stringify(tradeData)));
                // 여러 번 시도하여 확실히 그리기
                setTimeout(() => {
                    drawOverlay();
                }, 50);
                setTimeout(() => {
                    drawOverlay();
                }, 200);
                setTimeout(() => {
                    drawOverlay();
                }, 500);
            } else {
                console.log('No update needed');
            }
        };

        window.setPositionType = function(type) {
            positionType = type;
            console.log('Position type set to:', positionType);
        };
        
        window.setLiquidationPrice = function(price) {
            console.log('setLiquidationPrice called with:', price);
            if (price !== undefined && price !== null && price !== '') {
                const lpValue = parseFloat(price);
                if (!isNaN(lpValue) && lpValue > 0) {
                    tradeData.liquidationPrice = lpValue;
                    console.log('Liquidation price updated to:', lpValue);
                    setTimeout(() => {
                        drawOverlay();
                    }, 50);
                    setTimeout(() => {
                        drawOverlay();
                    }, 200);
                } else if (price === '' || price === '0' || price === '0.00') {
                    tradeData.liquidationPrice = null;
                    console.log('Liquidation price cleared');
                    setTimeout(() => {
                        drawOverlay();
                    }, 50);
                }
            }
        };
        
        // ========== 타임프레임 설정 ==========
        let currentTimeframe = '1h';
        window.setTimeframe = function(timeframe) {
            currentTimeframe = timeframe;
            console.log('Timeframe set to:', currentTimeframe);
        };

        // ========== 초기화 ==========
        function waitForLibrary(callback, maxAttempts = 50) {
            let attempts = 0;
            const checkLibrary = () => {
                attempts++;
                if (typeof LightweightCharts !== 'undefined' &&
                    typeof LightweightCharts.createChart === 'function') {
                    callback();
                } else if (attempts < maxAttempts) {
                    setTimeout(checkLibrary, 100);
                } else {
                    console.error('LightweightCharts library failed to load');
                }
            };
            checkLibrary();
        }

        window.addEventListener('load', () => {
            waitForLibrary(() => {
                console.log('LightweightCharts library loaded successfully');
                initChart();
                initCanvas();

                chartReady = true;
                console.log('Chart ready');
                
                // 초기 시간 표시
                updateTimeDisplay();

                if (pendingKlines) {
                    console.log('Processing pending klines');
                    window.setOHLCData(pendingKlines);
                    pendingKlines = null;
                }

                // 차트가 완전히 렌더링된 후 오버레이 그리기 (여러 번 시도)
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (first attempt)');
                    drawOverlay();
                }, 500);
                
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (second attempt)');
                    drawOverlay();
                }, 1000);
                
                setTimeout(() => {
                    console.log('Drawing initial overlay after chart ready (third attempt)');
                    drawOverlay();
                }, 2000);

                // 리사이즈 핸들러
                window.addEventListener('resize', () => {
                    if (chart && canvas) {
                        resizeCanvas();
                        setTimeout(() => {
                            drawOverlay();
                        }, 100);
                    }
                });

                // 차트 스케일 변경 시 오버레이 다시 그리기
                if (chart && candlestickSeries) {
                    chart.timeScale().subscribeVisibleLogicalRangeChange(() => {
                        setTimeout(() => {
                            drawOverlay();
                        }, 50);
                    });
                }

                if (window.Android && typeof window.Android.onChartReady === 'function') {
                    window.Android.onChartReady();
                }
            });
        });
    </script>
</body>
</html>
